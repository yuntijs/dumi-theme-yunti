!(function(){"use strict";var K=Object.defineProperty,Q=Object.defineProperties;var Y=Object.getOwnPropertyDescriptors;var L=Object.getOwnPropertySymbols;var X=Object.prototype.hasOwnProperty,G=Object.prototype.propertyIsEnumerable;var B=(y,p,S)=>p in y?K(y,p,{enumerable:!0,configurable:!0,writable:!0,value:S}):y[p]=S,x=(y,p)=>{for(var S in p||(p={}))X.call(p,S)&&B(y,S,p[S]);if(L)for(var S of L(p))G.call(p,S)&&B(y,S,p[S]);return y},q=(y,p)=>Q(y,Y(p));var $=(y,p)=>{var S={};for(var b in y)X.call(y,b)&&p.indexOf(b)<0&&(S[b]=y[b]);if(y!=null&&L)for(var b of L(y))p.indexOf(b)<0&&G.call(y,b)&&(S[b]=y[b]);return S};(self.webpackChunkdumi_theme_yunti_example=self.webpackChunkdumi_theme_yunti_example||[]).push([[3285],{51319:function(y,p,S){var b=S(92379);function A(s,i){return s===i&&(s!==0||1/s===1/i)||s!==s&&i!==i}var J=typeof Object.is=="function"?Object.is:A,N=b.useState,P=b.useEffect,U=b.useLayoutEffect,z=b.useDebugValue;function H(s,i){var g=i(),E=N({inst:{value:g,getSnapshot:i}}),O=E[0].inst,D=E[1];return U(function(){O.value=g,O.getSnapshot=i,W(O)&&D({inst:O})},[s,g,i]),P(function(){return W(O)&&D({inst:O}),s(function(){W(O)&&D({inst:O})})},[s]),z(g),g}function W(s){var i=s.getSnapshot;s=s.value;try{var g=i();return!J(s,g)}catch(E){return!0}}function C(s,i){return i()}var j=typeof window=="undefined"||typeof window.document=="undefined"||typeof window.document.createElement=="undefined"?C:H;p.useSyncExternalStore=b.useSyncExternalStore!==void 0?b.useSyncExternalStore:j},98666:function(y,p,S){var b=S(92379),A=S(69710);function J(C,j){return C===j&&(C!==0||1/C===1/j)||C!==C&&j!==j}var N=typeof Object.is=="function"?Object.is:J,P=A.useSyncExternalStore,U=b.useRef,z=b.useEffect,H=b.useMemo,W=b.useDebugValue;p.useSyncExternalStoreWithSelector=function(C,j,s,i,g){var E=U(null);if(E.current===null){var O={hasValue:!1,value:null};E.current=O}else O=E.current;E=H(function(){function f(e){if(!a){if(a=!0,n=e,e=i(e),g!==void 0&&O.hasValue){var v=O.value;if(g(v,e))return r=v}return r=e}if(v=r,N(n,e))return v;var u=i(e);return g!==void 0&&g(v,u)?v:(n=e,r=u)}var a=!1,n,r,t=s===void 0?null:s;return[function(){return f(j())},t===null?void 0:function(){return f(t())}]},[j,s,i,g]);var D=P(C,E[0],E[1]);return z(function(){O.hasValue=!0,O.value=D},[D]),W(D),D}},69710:function(y,p,S){y.exports=S(51319)},84171:function(y,p,S){y.exports=S(98666)},32089:function(y,p,S){S.d(p,{mW:function(){return z},tJ:function(){return D}});const b=(f,a)=>(n,r,t)=>(t.dispatch=e=>(n(v=>f(v,e),!1,e),e),t.dispatchFromDevtools=!0,x({dispatch:(...e)=>t.dispatch(...e)},a)),A=null,J=new Map,N=f=>{const a=J.get(f);return a?Object.fromEntries(Object.entries(a.stores).map(([n,r])=>[n,r.getState()])):{}},P=(f,a,n)=>{if(f===void 0)return{type:"untracked",connection:a.connect(n)};const r=J.get(n.name);if(r)return x({type:"tracked",store:f},r);const t={connection:a.connect(n),stores:{}};return J.set(n.name,t),x({type:"tracked",store:f},t)},z=(f,a={})=>(n,r,t)=>{const m=a,{enabled:e,anonymousActionType:v,store:u}=m,w=$(m,["enabled","anonymousActionType","store"]);let _;try{_=(e!=null?e:!0)&&window.__REDUX_DEVTOOLS_EXTENSION__}catch(c){}if(!_)return e&&console.warn("[zustand devtools middleware] Please install/enable Redux devtools extension"),f(n,r,t);const d=P(u,_,w),{connection:h}=d,T=$(d,["connection"]);let k=!0;t.setState=(c,o,l)=>{const F=n(c,o);if(!k)return F;const M=l===void 0?{type:v||"anonymous"}:typeof l=="string"?{type:l}:l;return u===void 0?(h==null||h.send(M,r()),F):(h==null||h.send(q(x({},M),{type:`${u}/${M.type}`}),q(x({},N(w.name)),{[u]:t.getState()})),F)};const I=(...c)=>{const o=k;k=!1,n(...c),k=o},R=f(t.setState,r,t);if(T.type==="untracked"?h==null||h.init(R):(T.stores[T.store]=t,h==null||h.init(Object.fromEntries(Object.entries(T.stores).map(([c,o])=>[c,c===T.store?R:o.getState()])))),t.dispatchFromDevtools&&typeof t.dispatch=="function"){let c=!1;const o=t.dispatch;t.dispatch=(...l)=>{l[0].type==="__setState"&&!c&&(console.warn('[zustand devtools middleware] "__setState" action type is reserved to set state from the devtools. Avoid using it.'),c=!0),o(...l)}}return h.subscribe(c=>{var o;switch(c.type){case"ACTION":if(typeof c.payload!="string"){console.error("[zustand devtools middleware] Unsupported action format");return}return H(c.payload,l=>{if(l.type==="__setState"){if(u===void 0){I(l.state);return}Object.keys(l.state).length!==1&&console.error(`
                    [zustand devtools middleware] Unsupported __setState action format. 
                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),
                    and value of this only key should be a state object. Example: { "type": "__setState", "state": { "abc123Store": { "foo": "bar" } } }
                    `);const F=l.state[u];if(F==null)return;JSON.stringify(t.getState())!==JSON.stringify(F)&&I(F);return}t.dispatchFromDevtools&&typeof t.dispatch=="function"&&t.dispatch(l)});case"DISPATCH":switch(c.payload.type){case"RESET":return I(R),u===void 0?h==null?void 0:h.init(t.getState()):h==null?void 0:h.init(N(w.name));case"COMMIT":if(u===void 0){h==null||h.init(t.getState());return}return h==null?void 0:h.init(N(w.name));case"ROLLBACK":return H(c.state,l=>{if(u===void 0){I(l),h==null||h.init(t.getState());return}I(l[u]),h==null||h.init(N(w.name))});case"JUMP_TO_STATE":case"JUMP_TO_ACTION":return H(c.state,l=>{if(u===void 0){I(l);return}JSON.stringify(t.getState())!==JSON.stringify(l[u])&&I(l[u])});case"IMPORT_STATE":{const{nextLiftedState:l}=c.payload,F=(o=l.computedStates.slice(-1)[0])==null?void 0:o.state;if(!F)return;I(u===void 0?F:F[u]),h==null||h.send(null,l);return}case"PAUSE_RECORDING":return k=!k}return}}),R},H=(f,a)=>{let n;try{n=JSON.parse(f)}catch(r){console.error("[zustand devtools middleware] Could not parse the received json",r)}n!==void 0&&a(n)},W=f=>(a,n,r)=>{const t=r.subscribe;return r.subscribe=(v,u,w)=>{let _=v;if(u){const h=(w==null?void 0:w.equalityFn)||Object.is;let T=v(r.getState());_=k=>{const I=v(k);if(!h(T,I)){const R=T;u(T=I,R)}},w!=null&&w.fireImmediately&&u(T,T)}return t(_)},f(a,n,r)},C=null,j=(f,a)=>(...n)=>Object.assign({},f,a(...n));function s(f,a){let n;try{n=f()}catch(t){return}return{getItem:t=>{var e;const v=w=>w===null?null:JSON.parse(w,a==null?void 0:a.reviver),u=(e=n.getItem(t))!=null?e:null;return u instanceof Promise?u.then(v):v(u)},setItem:(t,e)=>n.setItem(t,JSON.stringify(e,a==null?void 0:a.replacer)),removeItem:t=>n.removeItem(t)}}const i=f=>a=>{try{const n=f(a);return n instanceof Promise?n:{then(r){return i(r)(n)},catch(r){return this}}}catch(n){return{then(r){return this},catch(r){return i(r)(n)}}}},g=(f,a)=>(n,r,t)=>{let e=x({getStorage:()=>localStorage,serialize:JSON.stringify,deserialize:JSON.parse,partialize:d=>d,version:0,merge:(d,c)=>x(x({},c),d)},a),v=!1;const u=new Set,w=new Set;let _;try{_=e.getStorage()}catch(d){}if(!_)return f((...d)=>{console.warn(`[zustand persist middleware] Unable to update item '${e.name}', the given storage is currently unavailable.`),n(...d)},r,t);const h=i(e.serialize),T=()=>{const d=e.partialize(x({},r()));let c;const o=h({state:d,version:e.version}).then(l=>_.setItem(e.name,l)).catch(l=>{c=l});if(c)throw c;return o},k=t.setState;t.setState=(d,c)=>{k(d,c),T()};const I=f((...d)=>{n(...d),T()},r,t);let R;const m=()=>{var d;if(!_)return;v=!1,u.forEach(o=>o(r()));const c=((d=e.onRehydrateStorage)==null?void 0:d.call(e,r()))||void 0;return i(_.getItem.bind(_))(e.name).then(o=>{if(o)return e.deserialize(o)}).then(o=>{if(o)if(typeof o.version=="number"&&o.version!==e.version){if(e.migrate)return e.migrate(o.state,o.version);console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return o.state}).then(o=>{var l;return R=e.merge(o,(l=r())!=null?l:I),n(R,!0),T()}).then(()=>{c==null||c(R,void 0),v=!0,w.forEach(o=>o(R))}).catch(o=>{c==null||c(void 0,o)})};return t.persist={setOptions:d=>{e=x(x({},e),d),d.getStorage&&(_=d.getStorage())},clearStorage:()=>{_==null||_.removeItem(e.name)},getOptions:()=>e,rehydrate:()=>m(),hasHydrated:()=>v,onHydrate:d=>(u.add(d),()=>{u.delete(d)}),onFinishHydration:d=>(w.add(d),()=>{w.delete(d)})},m(),R||I},E=(f,a)=>(n,r,t)=>{let e=x({storage:s(()=>localStorage),partialize:m=>m,version:0,merge:(m,d)=>x(x({},d),m)},a),v=!1;const u=new Set,w=new Set;let _=e.storage;if(!_)return f((...m)=>{console.warn(`[zustand persist middleware] Unable to update item '${e.name}', the given storage is currently unavailable.`),n(...m)},r,t);const h=()=>{const m=e.partialize(x({},r()));return _.setItem(e.name,{state:m,version:e.version})},T=t.setState;t.setState=(m,d)=>{T(m,d),h()};const k=f((...m)=>{n(...m),h()},r,t);t.getInitialState=()=>k;let I;const R=()=>{var m,d;if(!_)return;v=!1,u.forEach(o=>{var l;return o((l=r())!=null?l:k)});const c=((d=e.onRehydrateStorage)==null?void 0:d.call(e,(m=r())!=null?m:k))||void 0;return i(_.getItem.bind(_))(e.name).then(o=>{if(o)if(typeof o.version=="number"&&o.version!==e.version){if(e.migrate)return e.migrate(o.state,o.version);console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return o.state}).then(o=>{var l;return I=e.merge(o,(l=r())!=null?l:k),n(I,!0),h()}).then(()=>{c==null||c(I,void 0),I=r(),v=!0,w.forEach(o=>o(I))}).catch(o=>{c==null||c(void 0,o)})};return t.persist={setOptions:m=>{e=x(x({},e),m),m.storage&&(_=m.storage)},clearStorage:()=>{_==null||_.removeItem(e.name)},getOptions:()=>e,rehydrate:()=>R(),hasHydrated:()=>v,onHydrate:m=>(u.add(m),()=>{u.delete(m)}),onFinishHydration:m=>(w.add(m),()=>{w.delete(m)})},e.skipHydration||R(),I||k},D=(f,a)=>"getStorage"in a||"serialize"in a||"deserialize"in a?(console.warn("[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead."),g(f,a)):E(f,a)},9676:function(y,p,S){S.d(p,{F:function(){return j}});var b=S(92379),A=S(84171);const J=s=>{let i;const g=new Set,E=(t,e)=>{const v=typeof t=="function"?t(i):t;if(!Object.is(v,i)){const u=i;i=(e!=null?e:typeof v!="object"||v===null)?v:Object.assign({},i,v),g.forEach(w=>w(i,u))}},O=()=>i,n={setState:E,getState:O,getInitialState:()=>r,subscribe:t=>(g.add(t),()=>g.delete(t)),destroy:()=>{console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."),g.clear()}},r=i=s(E,O,n);return n},N=s=>s?J(s):J;var P=s=>(console.warn("[DEPRECATED] Default export is deprecated. Instead use import { createStore } from 'zustand/vanilla'."),N(s));const{useDebugValue:U}=b,{useSyncExternalStoreWithSelector:z}=A,H=s=>s;function W(s,i=H,g){const E=z(s.subscribe,s.getState,s.getServerState||s.getInitialState,i,g);return U(E),E}const C=(s,i)=>{const g=N(s),E=(O,D=i)=>W(g,O,D);return Object.assign(E,g),E},j=(s,i)=>s?C(s,i):C}}]);
}());